# -*- coding: utf-8 -*-
"""Product_Master.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1avDC3l8Ru1jd690oIAlMhX50uZ-vLPxp
"""

# TDF Product Generator - Web Scrape for Tickers -> Yahoo Finance for Details

# Import necessary libraries
import pandas as pd
import numpy as np
import re
import logging
import requests
import yfinance as yf
import random
from typing import List, Dict, Any, Optional

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger('tdf_generator')

# STEP 1: Web Scrape to Collect Tickers

def get_tdf_tickers() -> list[str]:
    """
    Return a list of target date fund tickers (manually specified).

    Returns:
        List of ticker symbols
    """
    return [
        "VSVNX", "VLXVX", "VTTSX", "VFFVX", "VFIFX", "VTIVX",
        "VFORX", "VTTHX", "VTHRX", "VTTVX", "VTWNX", "VTINX"
    ]

# STEP 2: Plug Tickers into Yahoo Finance to Get Fund Information

def get_fund_info_from_yahoo(tickers: List[str]) -> Dict[str, Dict]:
    """
    Get fund information from Yahoo Finance for the given tickers

    Args:
        tickers: List of ticker symbols

    Returns:
        Dictionary mapping tickers to their fund information
    """
    fund_info = {}

    logger.info(f"Fetching fund information from Yahoo Finance for {len(tickers)} tickers...")
    for ticker in tickers:
        try:
            # Get fund information from yfinance
            fund = yf.Ticker(ticker)
            info = fund.info

            if info and 'shortName' in info:
                fund_info[ticker] = info
                logger.info(f"Found info for {ticker}: {info['shortName']}")
            else:
                logger.info(f"No information found for {ticker}")

        except Exception as e:
            logger.error(f"Error getting info for {ticker} from Yahoo Finance: {e}")

    logger.info(f"Successfully retrieved information for {len(fund_info)} tickers")
    return fund_info

def infer_fund_name_from_ticker(ticker: str, info: Dict) -> str:
    """
    Infer fund name from ticker and available information
    with no hardcoded ticker references
    """
    # Try to determine fund type and provider from any available information
    fund_type = "Target Date Fund"
    provider = ""
    is_income_fund = False
    target_year = None

    # Look for keywords in any description fields
    description_fields = ['description', 'longBusinessSummary', 'summary']
    for field in description_fields:
        if field in info and info[field]:
            description = info[field].lower()

            # Check for retirement income fund (no target year)
            if 'retirement income' in description or 'income fund' in description:
                is_income_fund = True
                fund_type = "Target Retirement Income Fund"
            # Look for target retirement fund with year
            elif ('target' in description and 'retirement' in description) or 'target date' in description:
                # Look for a year in the description (2020-2075)
                year_match = re.search(r'20([2-7][05])', description)
                if year_match:
                    target_year = year_match.group(0)
                    fund_type = f"Target Retirement {target_year} Fund"

            # Check for provider names
            providers = {
                'vanguard': 'Vanguard',
                'fidelity': 'Fidelity',
                't. rowe price': 'T. Rowe Price',
                't.rowe': 'T. Rowe Price',
                'blackrock': 'BlackRock'
            }

            for keyword, name in providers.items():
                if keyword in description.lower():
                    provider = name
                    break

    # If no provider found, try to infer from ticker
    if not provider:
        if ticker.startswith('VT'):
            provider = 'Vanguard'
        elif ticker.startswith('FF') or ticker.startswith('FI'):
            provider = 'Fidelity'
        elif ticker.startswith('TR'):
            provider = 'T. Rowe Price'

    # Special case for income funds based on ticker, understand that we don't want to hard code but will do it for now (doesn't impact rest of code)
    if ticker == "VTINX":
        fund_type = "Income Fund"

    # Construct name based on what we found
    if provider:
        if is_income_fund:
            return f"{provider} Target Retirement Income Fund"
        elif target_year:
            return f"{provider} Target Retirement {target_year} Fund"
        else:
            return f"{provider} {fund_type}"
    else:
        if is_income_fund:
            return "Target Retirement Income Fund"
        elif target_year:
            return f"Target Retirement {target_year} Fund"
        else:
            return f"Target Date Fund ({ticker})"

def create_ticker_to_name_mapping(tickers: List[str], fund_info: Dict[str, Dict]) -> Dict[str, str]:
    """
    Create mapping from tickers to fund names without hardcoding
    """
    ticker_to_name = {}

    for ticker in tickers:
        # First try to get the name from Yahoo Finance
        if ticker in fund_info:
            # Try different name fields in order of preference
            for name_field in ['longName', 'shortName', 'name']:
                if name_field in fund_info[ticker] and fund_info[ticker][name_field]:
                    name = fund_info[ticker][name_field]
                    # Check if the name is reasonable (not too short)
                    if len(name) > 5:
                        ticker_to_name[ticker] = name
                        break

        # If we still don't have a name, analyze the ticker and the information we have
        if ticker not in ticker_to_name or not ticker_to_name[ticker]:
            # Try to infer the name from the ticker and any available information
            name = infer_fund_name_from_ticker(ticker, fund_info.get(ticker, {}))
            ticker_to_name[ticker] = name

    return ticker_to_name

# STEP 3: Create Ticker to Product Code Mapping

def generate_product_code(index: int) -> str:
    """
    Generate a product code with sequential numbering

    Args:
        index: The index number for the product

    Returns:
        Product code in format PRD001, PRD002, etc.
    """
    return f"PRD{index:03d}"

def create_ticker_to_product_mapping(tickers: List[str]) -> Dict[str, str]:
    """
    Create a mapping from ticker symbols to product codes

    Args:
        tickers: List of ticker symbols

    Returns:
        Dictionary mapping tickers to product codes
    """
    ticker_to_product = {}

    for i, ticker in enumerate(tickers, start=1):
        product_code = generate_product_code(i)
        ticker_to_product[ticker] = product_code

    logger.info(f"Created product code mapping for {len(ticker_to_product)} tickers")
    return ticker_to_product

# STEP 4: Generate Product Master Data

def generate_account_codes(account_type='COMP') -> str:
    """
    Generate realistic account codes based on type

    Args:
        account_type: 'COMP' for performance accounts, 'MODEL' for representative accounts

    Returns:
        Account code string
    """
    # List of possible account code patterns
    patterns = [
        # Strategy-based codes
        lambda: f"ASTTDFCOMP" if account_type == 'COMP' else f"ASTTDFMODEL",
        lambda: f"ASTTDFMF" if account_type == 'COMP' else f"ASTTDFMODEL",
        # Numeric codes
        lambda: str(random.randint(1000, 3000)),
        # Letter-number codes
        lambda: f"LX{random.randint(100, 500)}",
        lambda: f"OC{random.randint(1000, 2000)}",
    ]

    # Select a pattern with weights (strategy-based codes more common)
    weights = [0.4, 0.3, 0.1, 0.1, 0.1]  # 70% strategy-based, 30% other patterns
    pattern = random.choices(patterns, weights=weights)[0]

    return pattern()

def create_product_record(product_code: str, fund_name: str, strategy: str) -> Dict:
    """
    Create a single product master record

    Args:
        product_code: Product code (e.g., PRD001)
        fund_name: Name of the fund
        strategy: Strategy ticker code (e.g., "VTINX")

    Returns:
        Dictionary with product master data
    """
    perf_account = generate_account_codes('COMP')
    repr_account = generate_account_codes('MODEL')

    if random.random() < 0.3:
        shared_code = f"LX{random.randint(100, 500)}" if random.random() < 0.5 else f"OC{random.randint(1000, 2000)}"
        perf_account = shared_code
        repr_account = shared_code

    return {
        "PRODUCTCODE": product_code,
        "PRODUCTNAME": fund_name,
        "STRATEGY": strategy,  # <-- use dynamic strategy here
        "VEHICLECATEGORY": "Pooled",
        "VEHICLETYPE": "Mutual Fund",
        "ASSETCLASS": "Multi-Asset",
        "SHARECLASS": None,
        "PERFORMANCEACCOUNT": perf_account,
        "REPRESENTATIVEACCOUNT": repr_account,
        "ISMARKETED": True,
        "PARENTPRODUCTCODE": None
    }

def generate_product_master_data(
    ticker_to_name: Dict[str, str],
    ticker_to_product: Dict[str, str]
) -> pd.DataFrame:
    """
    Generate product master data from ticker mappings

    Args:
        ticker_to_name: Dictionary mapping tickers to fund names
        ticker_to_product: Dictionary mapping tickers to product codes

    Returns:
        DataFrame containing product master data
    """
    # Hardcode override for VSVNX to ensure correct product name
    ticker_to_name = ticker_to_name.copy()  # avoid mutating original dict
    ticker_to_name['VSVNX'] = "Vanguard Target Retirement 2070 Fund"  # Hard coded it because was having issues retrieving name of fund from yfinance, doesn't impact rest of code

    # Create reverse lookup: fund name -> ticker
    name_to_ticker = {v: k for k, v in ticker_to_name.items()}

    products = []
    for ticker, product_code in ticker_to_product.items():
        fund_name = ticker_to_name.get(ticker, f"Target Date Fund ({ticker})")

        # Get strategy ticker by fund name; fallback to ticker if no match
        strategy = name_to_ticker.get(fund_name, ticker)

        product = create_product_record(product_code, fund_name, strategy)
        products.append(product)

    df_products = pd.DataFrame(products)

    expected_columns = [
        "PRODUCTCODE", "PRODUCTNAME", "STRATEGY", "VEHICLECATEGORY",
        "VEHICLETYPE", "ASSETCLASS", "SHARECLASS", "PERFORMANCEACCOUNT",
        "REPRESENTATIVEACCOUNT", "ISMARKETED", "PARENTPRODUCTCODE"
    ]

    for col in expected_columns:
        if col not in df_products.columns:
            df_products[col] = None

    df_products = df_products[expected_columns]

    logger.info(f"Generated product master data with {len(df_products)} records")

    return df_products

def main():
    """
    Main function to run the TDF product generator pipeline
    """
    # Get tickers
    tickers = get_tdf_tickers()
    logger.info(f"Collected {len(tickers)} tickers: {tickers}")

    # Get fund information from Yahoo Finance
    fund_info = get_fund_info_from_yahoo(tickers)

    # Create ticker to name mapping
    ticker_name_mapping = create_ticker_to_name_mapping(tickers, fund_info)

    logger.info("\nTicker to Fund Name Mapping:")
    for ticker, name in ticker_name_mapping.items():
        logger.info(f"{ticker}: {name}")

    # Create product code mapping
    mapping = create_ticker_to_product_mapping(tickers)

    logger.info("\nTicker to Product Mapping:")
    for ticker, product_code in mapping.items():
        logger.info(f"{ticker} -> {product_code}")

    # Generate product master data
    df_products = generate_product_master_data(ticker_name_mapping, mapping)

    logger.info(f"\nGenerated {len(df_products)} product records")
    logger.info("\nProduct Master Data (First 5 rows):")

    # Log the first 5 rows in a readable format
    for i, (idx, row) in enumerate(df_products.head().iterrows()):
        if i == 0:
            # Log header
            logger.info(", ".join(df_products.columns))
        # Log each row
        logger.info(", ".join(str(val) if val is not None else "None" for val in row))

    return df_products

if __name__ == "__main__":
    df_products = main()
    # Final success message
    logger.info("Product generation completed successfully.")