# -*- coding: utf-8 -*-
"""Benchmark_General_Information.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ho9-XZPGwUTj0Iyi0ERl0M07eJyFWEoS
"""

# Benchmark General Information Generator for Target Date Funds
# This module generates benchmark general information for the AST_MULTIASSET_DB.DBO.BENCHMARKGENERALINFORMATION table

import pandas as pd
import random
import logging

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Function to generate benchmark names
def generate_name():
    """
    Generate appropriate benchmark names for target date funds.

    Returns:
        str: A realistic benchmark name relevant for target date funds
    """
    # Target date specific benchmark patterns
    name_types = [
        # Standard market benchmarks used for TDFs
        lambda: f"{random.choice(['S&P Target Date', 'Morningstar Lifetime', 'Bloomberg US Agg', 'Russell Target Date', 'FTSE Target Date'])} {random.choice(['2025', '2030', '2035', '2040', '2045', '2050', '2055', '2060', '2065'])} Index",

        # Equity/Fixed Income blend benchmarks
        lambda: f"{random.randint(30, 80)}% {random.choice(['MSCI ACWI', 'S&P 500', 'MSCI World', 'Russell 3000'])} / {random.randint(20, 70)}% {random.choice(['Bloomberg Agg', 'Bloomberg US Treasury', 'FTSE World Gov Bond', 'ICE BofA US Corp'])}",

        # Composite benchmarks
        lambda: f"Composite {random.choice(['Target Retirement', 'Target Date', 'Lifecycle'])} {random.choice(['2025', '2030', '2035', '2040', '2045', '2050', '2055', '2060', '2065'])} Index",

        # Common industry benchmark combinations
        lambda: f"{random.choice(['MSCI ACWI IMI', 'Russell 3000', 'MSCI World', 'Bloomberg Global Agg'])} {random.choice(['Target Date', 'Retirement', 'Lifecycle'])} Benchmark",

        # Risk-based benchmark allocations
        lambda: f"{random.choice(['Conservative', 'Moderate', 'Balanced', 'Growth', 'Aggressive'])} {random.randint(20, 80)}% Equity Benchmark",

        # Standard industry glide path benchmarks
        lambda: f"{random.choice(['S&P', 'Morningstar', 'FTSE', 'Bloomberg'])} Target Date {random.choice(['2025', '2030', '2035', '2040', '2045', '2050', '2055', '2060', '2065'])} {random.choice(['Index', 'Benchmark', 'Composite'])}"
    ]
    return random.choice(name_types)()

def generate_benchmark_general_information(num_records=20, benchmark_codes=None):
    """
    Generate a DataFrame with benchmark general information for target date funds.

    Creates data for the AST_MULTIASSET_DB.DBO.BENCHMARKGENERALINFORMATION table.

    Args:
        num_records (int): Total number of benchmark records to generate
        benchmark_codes (list): List of benchmark codes to use. Default is ["GSPC"]

    Returns:
        pandas.DataFrame: DataFrame with generated benchmark general information
    """
    # Default to GSPC if no benchmark codes provided
    if benchmark_codes is None:
        benchmark_codes = ["GSPC"]

    logger.info(f"Generating {num_records} benchmark general information records")
    data = []

    # FAIR DISTRIBUTION ALGORITHM:
    # We use this specific algorithm because:
    # 1. OPTIMAL FAIRNESS: It guarantees the most even possible distribution of records,
    #    where the difference between any two benchmark codes is at most 1 record.
    # 2. EFFICIENCY: It uses simple integer division and modulo operations with O(n) complexity,
    #    avoiding multiple passes through data or complex calculations.
    # 3. DETERMINISTIC: Produces consistent results with the same inputs, making testing easier.
    # 4. INDUSTRY STANDARD: This is a common pattern used for load balancing, sharding,
    #    and resource allocation across distributed systems.
    # 5. SIMPLICITY: The algorithm is straightforward to understand, implement, and maintain.

    # Calculate the base number of records per benchmark code (integer division)
    records_per_code = num_records // len(benchmark_codes)

    # Calculate any leftover records after even distribution (remainder)
    remaining_records = num_records % len(benchmark_codes)

    # Generate benchmark records for each code
    for code in benchmark_codes:
        # Start with the base allocation for this code
        code_records = records_per_code

        # If there are remaining records, give one to this code and decrement the counter
        # This ensures any extra records are distributed evenly, one per code
        if remaining_records > 0:
            code_records += 1  # Add an extra record to this code
            remaining_records -= 1  # One fewer remaining record to distribute

        logger.info(f"Generating {code_records} records for benchmark code: {code}")

        # Generate the records for this benchmark code
        for _ in range(code_records):
            data.append({
                "BENCHMARKCODE": code,
                "SYMBOL": "BLANK",  # All symbols set to "BLANK" as requested
                "NAME": generate_name(),
                "ISBEGINOFDAYPERFORMANCE": False  # All were FALSE in sample data
            })

    df = pd.DataFrame(data)
    logger.info(f"Generated {len(df)} benchmark general information records")
    return df

def analyze_name_patterns(df):
    """
    Analyze the distribution of different name patterns in the generated benchmarks

    Args:
        df: DataFrame containing benchmark data

    Returns:
        dict: Mapping of patterns to counts
    """
    patterns = {
        'Target Date': 0,
        'S&P': 0,
        'Morningstar': 0,
        'Bloomberg': 0,
        'Composite': 0,
        'MSCI': 0,
        'Russell': 0,
        'Equity %': 0
    }

    for name in df['NAME']:
        if 'Target Date' in name:
            patterns['Target Date'] += 1
        if 'S&P' in name:
            patterns['S&P'] += 1
        if 'Morningstar' in name:
            patterns['Morningstar'] += 1
        if 'Bloomberg' in name:
            patterns['Bloomberg'] += 1
        if 'Composite' in name:
            patterns['Composite'] += 1
        if 'MSCI' in name:
            patterns['MSCI'] += 1
        if 'Russell' in name:
            patterns['Russell'] += 1
        if '%' in name:
            patterns['Equity %'] += 1

    return patterns

def main():
    """
    Main function to generate benchmark general information

    Returns:
        pandas.DataFrame: Generated benchmark information
    """
    # Generate benchmark data for both GSPC and AGG
    total_records = 20
    benchmark_codes = ["GSPC", "AGG"]

    logger.info("Starting benchmark general information data generation")
    df_benchmarks = generate_benchmark_general_information(
        num_records=total_records,
        benchmark_codes=benchmark_codes
    )

    # Verify that all symbols are set to "BLANK"
    symbol_check = df_benchmarks['SYMBOL'].unique().tolist()
    if len(symbol_check) == 1 and symbol_check[0] == "BLANK":
        logger.info("✓ All symbols are correctly set to 'BLANK'")
    else:
        logger.warning(f"⚠ Unexpected symbol values found: {symbol_check}")

    # Log record count by benchmark code
    code_counts = df_benchmarks['BENCHMARKCODE'].value_counts().to_dict()
    logger.info(f"Distribution of records by benchmark code: {code_counts}")

    # Analyze name patterns
    name_patterns = analyze_name_patterns(df_benchmarks)
    logger.info("Name pattern distribution:")
    for pattern, count in name_patterns.items():
        logger.info(f"- {pattern}: {count} records")

    logger.info(f"✓ Successfully generated {len(df_benchmarks)} benchmark general information records")

    return df_benchmarks

if __name__ == "__main__":
    # Generate the benchmark data
    df_benchmarks = main()

    # If running in an interactive environment, you can uncomment these to display the data
    # import matplotlib.pyplot as plt
    # plt.figure(figsize=(10, 6))
    # df_benchmarks['BENCHMARKCODE'].value_counts().plot(kind='bar')
    # plt.title('Benchmark Code Distribution')
    # plt.tight_layout()
    # plt.show()